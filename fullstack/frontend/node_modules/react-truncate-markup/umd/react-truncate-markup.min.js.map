{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///react-truncate-markup.min.js","webpack:///webpack/bootstrap 4b50cb917cb1bf04cc02","webpack:///./src/index.js","webpack:///external {\"root\":\"React\",\"commonjs2\":\"react\",\"commonjs\":\"react\",\"amd\":\"react\"}","webpack:///./node_modules/line-height/lib/line-height.js","webpack:///./node_modules/computed-style/dist/computedStyle.commonjs.js","webpack:///./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js","webpack:///(webpack)/buildin/global.js","webpack:///./src/tokenize-rules.js"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_2__","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","constructor","value","writable","setPrototypeOf","__proto__","TruncateMarkup","_class","_temp2","__WEBPACK_IMPORTED_MODULE_0_react__","__WEBPACK_IMPORTED_MODULE_0_react___default","__WEBPACK_IMPORTED_MODULE_1_line_height__","__WEBPACK_IMPORTED_MODULE_1_line_height___default","__WEBPACK_IMPORTED_MODULE_2_resize_observer_polyfill__","__WEBPACK_IMPORTED_MODULE_3__tokenize_rules__","_typeof","Symbol","iterator","obj","_extends","assign","target","arguments","length","source","key","SPLIT","LEFT","RIGHT","toString","node","string","undefined","Array","isArray","newString","forEach","child","props","children","getTokenizePolicyByProp","tokenize","characters","cloneWithChildren","isRootEl","level","style","display","validateTree","type","reduce","isValid","_React$Component","_temp","_this","_ret","_len","args","_key","apply","concat","state","text","childrenElementWithRef","lineHeight","splitDirectionSeq","shouldTruncate","wasLastCharTested","endFound","latestThatFits","origText","onTruncateCalled","policy","onTruncate","wasTruncated","handleResize","initialRender","resizeObserver","setState","truncate","observe","el","componentDidMount","UNSAFE_componentWillReceiveProps","nextProps","_this2","disconnect","componentDidUpdate","fits","splice","push","tryToFit","componentWillUnmount","truncateOriginalText","_this3","a","Children","only","cloneElement","ref","rootEl","splitDirections","newRootEl","split","ellipsis","newChildren","newChildrenWithEllipsis","shouldRenderEllipsis","wordWrap","isRoot","splitString","splitArray","isAtomic","tokenizeString","join","splitDirection","restSplitDirections","slice","pivotIndex","Math","ceil","beforeString","substring","afterString","array","item","beforeArray","afterArray","maxLines","lines","_el$getBoundingClient","getBoundingClientRect","height","computedLines","round","parseFloat","render","Component","defaultProps","lnHeightStr","computedStyle","lnHeight","_lnHeightStyle","indexOf","nodeName","_node","document","createElement","innerHTML","toUpperCase","setAttribute","fontSizeStr","fontSize","padding","border","body","appendChild","offsetHeight","removeChild","prop","getComputedStyle","window","currentStyle","replace","word","letter","global","toFloat","getBordersSize","styles","positions","len","size","position","getPaddings","paddings","list","getSVGContentRect","bbox","getBBox","createRectInit","width","getHTMLElementContentRect","clientWidth","clientHeight","emptyRect","getWindowOf","horizPad","left","right","vertPad","top","bottom","boxSizing","isDocumentElement","vertScrollbar","horizScrollbar","abs","documentElement","getContentRect","isBrowser","isSVGGraphicsElement","createReadOnlyRect","x","y","Constr","DOMRectReadOnly","rect","defineConfigurable","MapShim","getIndex","arr","result","some","entry","index","Map","anonymous","__entries__","prototypeAccessors","set","delete","entries","has","clear","callback","ctx","this$1","defineProperties","global$1","Function","requestAnimationFrame$1","requestAnimationFrame","bind","setTimeout","Date","now","trailingTimeout","throttle","delay","resolvePending","leadingCall","trailingCall","proxy","timeoutCallback","timeStamp","lastCallTime","transitionKeys","mutationObserverSupported","MutationObserver","ResizeObserverController","connected_","mutationEventsAdded_","mutationsObserver_","observers_","onTransitionEnd_","refresh","addObserver","observer","connect_","removeObserver","observers","disconnect_","updateObservers_","activeObservers","filter","gatherActive","hasActive","broadcastActive","addEventListener","attributes","childList","characterData","subtree","removeEventListener","propertyName","getInstance","instance_","keys","ownerDocument","defaultView","SVGGraphicsElement","SVGElement","ResizeObservation","broadcastWidth","broadcastHeight","contentRect_","isActive","broadcastRect","ResizeObserverEntry","rectInit","contentRect","ResizeObserverSPI","controller","callbackCtx","activeObservations_","observations_","callback_","controller_","callbackCtx_","Element","observations","unobserve","clearActive","observation","map","WeakMap","ResizeObserver","method","g","eval","e","TOKENIZE_POLICY","str","words","match","test"],"mappings":"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","file":"react-truncate-markup.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ReactTruncateMarkup\"] = factory(require(\"react\"));\n\telse\n\t\troot[\"ReactTruncateMarkup\"] = factory(root[\"React\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_2__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ReactTruncateMarkup\"] = factory(require(\"react\"));\n\telse\n\t\troot[\"ReactTruncateMarkup\"] = factory(root[\"React\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_2__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(1);\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return TruncateMarkup; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_line_height__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_line_height___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_line_height__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_resize_observer_polyfill__ = __webpack_require__(5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__tokenize_rules__ = __webpack_require__(7);\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _class, _temp2;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\n\n\nvar SPLIT = {\n  LEFT: true,\n  RIGHT: false\n};\n\nvar toString = function toString(node) {\n  var string = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\n  if (!node) {\n    return string;\n  } else if (typeof node === 'string') {\n    return string + node;\n  } else if (Array.isArray(node)) {\n    var newString = string;\n    node.forEach(function (child) {\n      newString = toString(child, newString);\n    });\n\n    return newString;\n  }\n\n  return toString(node.props.children, string);\n};\n\nvar getTokenizePolicyByProp = function getTokenizePolicyByProp(tokenize) {\n  if (false) {\n    /* eslint-disable no-console */\n    console.warn('ReactTruncateMarkup: Unknown option for prop \\'tokenize\\': \\'' + tokenize + '\\'. Option \\'characters\\' will be used instead.');\n    /* eslint-enable */\n  }\n\n  return __WEBPACK_IMPORTED_MODULE_3__tokenize_rules__[\"a\" /* default */][tokenize] || __WEBPACK_IMPORTED_MODULE_3__tokenize_rules__[\"a\" /* default */].characters;\n};\n\nvar cloneWithChildren = function cloneWithChildren(node, children, isRootEl, level) {\n  return _extends({}, node, {\n    props: _extends({}, node.props, {\n      style: _extends({}, node.props.style, isRootEl ? {\n        // root element cannot be an inline element because of the line calculation\n        display: (node.props.style || {}).display || 'block'\n      } : level === 2 ? {\n        // level 2 elements (direct children of the root element) need to be inline because of the ellipsis.\n        // if level 2 element was a block element, ellipsis would get rendered on a new line, breaking the max number of lines\n        display: (node.props.style || {}).display || 'inline-block'\n      } : {}),\n      children: children\n    })\n  });\n};\n\nvar validateTree = function validateTree(node) {\n  if (typeof node === 'string') {\n    return true;\n  } else if (typeof node.type === 'function') {\n    if (false) {\n      /* eslint-disable no-console */\n      console.error('ReactTruncateMarkup tried to render <' + node.type.name + ' />, but truncating React components is not supported, the full content is rendered instead. Only DOM elements are supported.');\n      /* eslint-enable */\n    }\n\n    return false;\n  }\n\n  if (node.props.children) {\n    if (Array.isArray(node.props.children)) {\n      return node.props.children.reduce(function (isValid, child) {\n        return isValid && validateTree(child);\n      }, true);\n    }\n\n    return validateTree(node.props.children);\n  }\n\n  return true;\n};\n\nvar TruncateMarkup = (_temp2 = _class = function (_React$Component) {\n  _inherits(TruncateMarkup, _React$Component);\n\n  function TruncateMarkup() {\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, TruncateMarkup);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {\n      text: _this.childrenElementWithRef(_this.props.children)\n    }, _this.isValid = validateTree(_this.props.children), _this.lineHeight = null, _this.splitDirectionSeq = [], _this.shouldTruncate = true, _this.wasLastCharTested = false, _this.endFound = false, _this.latestThatFits = null, _this.origText = null, _this.onTruncateCalled = false, _this.policy = null, _this.onTruncate = function (wasTruncated) {\n      if (!_this.onTruncateCalled) {\n        _this.onTruncateCalled = true;\n        _this.props.onTruncate(wasTruncated);\n      }\n    }, _this.handleResize = function () {\n      /* Wrapper element resize handing */\n      var initialRender = true;\n\n      _this.resizeObserver = new __WEBPACK_IMPORTED_MODULE_2_resize_observer_polyfill__[\"a\" /* default */](function () {\n        if (initialRender) {\n          // ResizeObserer cb is called on initial render too so we are skipping here\n          initialRender = false;\n        } else {\n          // wrapper element has been resized, recalculating with the original text\n          _this.shouldTruncate = false;\n          _this.latestThatFits = null;\n\n          _this.setState({\n            text: _this.origText\n          }, function () {\n            _this.shouldTruncate = true;\n            _this.onTruncateCalled = false;\n            _this.truncate();\n          });\n        }\n      });\n\n      _this.resizeObserver.observe(_this.el);\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  TruncateMarkup.prototype.componentDidMount = function componentDidMount() {\n    if (!this.isValid) {\n      return;\n    }\n\n    this.origText = this.state.text;\n\n    // get the computed line-height of the parent element\n    // it'll be used for determining whether the text fits the container or not\n    this.lineHeight = this.props.lineHeight || __WEBPACK_IMPORTED_MODULE_1_line_height___default()(this.el);\n    this.policy = getTokenizePolicyByProp(this.props.tokenize);\n    this.truncate();\n\n    this.handleResize();\n  };\n\n  TruncateMarkup.prototype.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(nextProps) {\n    var _this2 = this;\n\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n    }\n    this.policy = getTokenizePolicyByProp(nextProps.tokenize);\n    this.shouldTruncate = false;\n    this.latestThatFits = null;\n    this.isValid = validateTree(nextProps.children);\n\n    this.setState({\n      text: this.childrenElementWithRef(nextProps.children)\n    }, function () {\n      if (!_this2.isValid) {\n        return;\n      }\n\n      _this2.origText = _this2.state.text;\n      _this2.lineHeight = nextProps.lineHeight || __WEBPACK_IMPORTED_MODULE_1_line_height___default()(_this2.el);\n      _this2.shouldTruncate = true;\n      _this2.truncate();\n\n      _this2.handleResize();\n    });\n  };\n\n  TruncateMarkup.prototype.componentDidUpdate = function componentDidUpdate() {\n    if (this.shouldTruncate === false || this.isValid === false) {\n      return;\n    }\n\n    if (this.endFound) {\n      // we've found the end where we cannot split the text further\n      // that means we've already found the max subtree that fits the container\n      // so we are rendering that\n      if (this.state.text !== this.latestThatFits) {\n        /* eslint-disable react/no-did-update-set-state */\n        this.setState({\n          text: this.latestThatFits\n        });\n\n        return;\n        /* eslint-enable */\n      }\n\n      this.onTruncate( /* wasTruncated */true);\n\n      return;\n    }\n\n    if (this.splitDirectionSeq.length) {\n      if (this.fits()) {\n        this.latestThatFits = this.state.text;\n        // we've found a subtree that fits the container\n        // but we need to check if we didn't cut too much of it off\n        // so we are changing the last splitting decision from splitting and going left\n        // to splitting and going right\n        this.splitDirectionSeq.splice(this.splitDirectionSeq.length - 1, 1, SPLIT.RIGHT, SPLIT.LEFT);\n      } else {\n        this.splitDirectionSeq.push(SPLIT.LEFT);\n      }\n\n      this.tryToFit(this.origText, this.splitDirectionSeq);\n    }\n  };\n\n  TruncateMarkup.prototype.componentWillUnmount = function componentWillUnmount() {\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n    }\n\n    this.lineHeight = null;\n    this.origText = null;\n    this.latestThatFits = null;\n    this.splitDirectionSeq = [];\n  };\n\n  TruncateMarkup.prototype.truncate = function truncate() {\n    if (this.fits()) {\n      // the whole text fits on the first try, no need to do anything else\n      this.shouldTruncate = false;\n      this.onTruncate( /* wasTruncated */false);\n\n      return;\n    }\n\n    this.truncateOriginalText();\n  };\n\n  TruncateMarkup.prototype.childrenElementWithRef = function childrenElementWithRef(children) {\n    var _this3 = this;\n\n    var child = __WEBPACK_IMPORTED_MODULE_0_react___default.a.Children.only(children);\n\n    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.cloneElement(child, { ref: function ref(el) {\n        return _this3.el = el;\n      } });\n  };\n\n  TruncateMarkup.prototype.truncateOriginalText = function truncateOriginalText() {\n    this.endFound = false;\n    this.splitDirectionSeq = [SPLIT.LEFT];\n    this.wasLastCharTested = false;\n\n    this.tryToFit(this.origText, this.splitDirectionSeq);\n  };\n\n  /**\n   * Splits rootEl based on instructions and updates React's state with the returned element\n   * After React rerenders the new text, we'll check if the new text fits in componentDidUpdate\n   * @param  {ReactElement} rootEl - the original children element\n   * @param  {Array} splitDirections - list of SPLIT.RIGHT/LEFT instructions\n   */\n\n\n  TruncateMarkup.prototype.tryToFit = function tryToFit(rootEl, splitDirections) {\n    if (!rootEl.props.children) {\n      // no markup in container\n      return;\n    }\n\n    var newRootEl = this.split(rootEl, splitDirections, /* isRootEl */true);\n\n    var ellipsis = typeof this.props.ellipsis === 'function' ? this.props.ellipsis(newRootEl) : this.props.ellipsis;\n\n    ellipsis = (typeof ellipsis === 'undefined' ? 'undefined' : _typeof(ellipsis)) === 'object' ? __WEBPACK_IMPORTED_MODULE_0_react___default.a.cloneElement(ellipsis, { key: 'ellipsis' }) : ellipsis;\n\n    var newChildren = newRootEl.props.children;\n    var newChildrenWithEllipsis = Array.isArray(newChildren) ? [].concat(newChildren, [ellipsis]) : [newChildren, ellipsis];\n\n    // edge case tradeoff EC#1 - on initial render it doesn't fit in the requested number of lines (1) so it starts truncating\n    // - because of truncating and the ellipsis position, div#lvl2 will have display set to 'inline-block',\n    //   causing the whole body to fit in 1 line again\n    // - if that happens, ellipsis is not needed anymore as the whole body is rendered\n    // - NOTE this could be fixed by checking for this exact case and handling it separately so it renders <div>foo {ellipsis}</div>\n    //\n    // Example:\n    // <TruncateMarkup lines={1}>\n    //   <div>\n    //     foo\n    //     <div id=\"lvl2\">bar</div>\n    //   </div>\n    // </TruncateMarkup>\n    var shouldRenderEllipsis = toString(newChildren) !== toString(this.origText);\n\n    this.setState({\n      text: _extends({}, newRootEl, {\n        props: _extends({}, newRootEl.props, {\n          style: _extends({\n            wordWrap: 'break-word'\n          }, newRootEl.props.style),\n          children: shouldRenderEllipsis ? newChildrenWithEllipsis : newChildren\n        })\n      })\n    });\n  };\n\n  /**\n   * Splits JSX node based on its type\n   * @param  {null|string|Array|Object} node - JSX node\n   * @param  {Array} splitDirections - list of SPLIT.RIGHT/LEFT instructions\n   * @return {null|string|Array|Object} - split JSX node\n   */\n\n\n  TruncateMarkup.prototype.split = function split(node, splitDirections) {\n    var isRoot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var level = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n\n    if (!node) {\n      return node;\n    } else if (typeof node === 'string') {\n      return this.splitString(node, splitDirections, level);\n    } else if (Array.isArray(node)) {\n      return this.splitArray(node, splitDirections, level);\n    }\n\n    var newChildren = this.split(node.props.children, splitDirections,\n    /* isRoot */false, level + 1);\n\n    return cloneWithChildren(node, newChildren, isRoot, level);\n  };\n\n  TruncateMarkup.prototype.splitString = function splitString(string) {\n    var splitDirections = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var level = arguments[2];\n\n    if (!splitDirections.length) {\n      return string;\n    }\n\n    if (splitDirections.length && this.policy.isAtomic(string)) {\n      // allow for an extra render test with the current character included\n      // in most cases this variation was already tested, but some edge cases require this check\n      // NOTE could be removed once EC#1 is taken care of\n      if (!this.wasLastCharTested) {\n        this.wasLastCharTested = true;\n      } else {\n        // we are trying to split further but we have nowhere to go now\n        // that means we've already found the max subtree that fits the container\n        this.endFound = true;\n      }\n\n      return string;\n    }\n\n    if (this.policy.tokenizeString) {\n      var wordsArray = this.splitArray(this.policy.tokenizeString(string), splitDirections, level);\n\n      // in order to preserve the input structure\n      return wordsArray.join('');\n    }\n\n    var splitDirection = splitDirections[0],\n        restSplitDirections = splitDirections.slice(1);\n\n    var pivotIndex = Math.ceil(string.length / 2);\n    var beforeString = string.substring(0, pivotIndex);\n\n    if (splitDirection === SPLIT.LEFT) {\n      return this.splitString(beforeString, restSplitDirections, level);\n    }\n    var afterString = string.substring(pivotIndex);\n\n    return beforeString + this.splitString(afterString, restSplitDirections, level);\n  };\n\n  TruncateMarkup.prototype.splitArray = function splitArray(array) {\n    var splitDirections = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var level = arguments[2];\n\n    if (!splitDirections.length) {\n      return array;\n    }\n\n    if (array.length === 1) {\n      var item = array[0];\n\n\n      if (typeof item === 'string') {\n        return [this.splitString(item, splitDirections, level)];\n      }\n      var children = item.props.children;\n\n\n      var newChildren = this.split(children, splitDirections,\n      /* isRoot */false, level + 1);\n\n      return [cloneWithChildren(item, newChildren, /* isRoot */false, level)];\n    }\n\n    var splitDirection = splitDirections[0],\n        restSplitDirections = splitDirections.slice(1);\n\n    var pivotIndex = Math.ceil(array.length / 2);\n    var beforeArray = array.slice(0, pivotIndex);\n\n    if (splitDirection === SPLIT.LEFT) {\n      return this.splitArray(beforeArray, restSplitDirections, level);\n    }\n    var afterArray = array.slice(pivotIndex);\n\n    return beforeArray.concat(this.splitArray(afterArray, restSplitDirections, level));\n  };\n\n  TruncateMarkup.prototype.fits = function fits() {\n    var maxLines = this.props.lines;\n\n    var _el$getBoundingClient = this.el.getBoundingClientRect(),\n        height = _el$getBoundingClient.height;\n\n    var computedLines = Math.round(height / parseFloat(this.lineHeight));\n\n    if (false) {\n      /* eslint-disable no-console */\n      console.warn('ReactTruncateMarkup: number of currently rendered lines: ' + computedLines + ', not truncating...\\n  It may be caused by target element not being visible at the time of computation.');\n      /* eslint-enable */\n    }\n\n    return maxLines >= computedLines;\n  };\n\n  TruncateMarkup.prototype.render = function render() {\n    return this.state.text;\n  };\n\n  return TruncateMarkup;\n}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component), _class.defaultProps = {\n  lines: 1,\n  ellipsis: '...',\n  lineHeight: '',\n  onTruncate: function onTruncate() {},\n  tokenize: 'characters'\n}, _temp2);\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// Load in dependencies\nvar computedStyle = __webpack_require__(4);\n\n/**\n * Calculate the `line-height` of a given node\n * @param {HTMLElement} node Element to calculate line height of. Must be in the DOM.\n * @returns {Number} `line-height` of the element in pixels\n */\nfunction lineHeight(node) {\n  // Grab the line-height via style\n  var lnHeightStr = computedStyle(node, 'line-height');\n  var lnHeight = parseFloat(lnHeightStr, 10);\n\n  // If the lineHeight did not contain a unit (i.e. it was numeric), convert it to ems (e.g. '2.3' === '2.3em')\n  if (lnHeightStr === lnHeight + '') {\n    // Save the old lineHeight style and update the em unit to the element\n    var _lnHeightStyle = node.style.lineHeight;\n    node.style.lineHeight = lnHeightStr + 'em';\n\n    // Calculate the em based height\n    lnHeightStr = computedStyle(node, 'line-height');\n    lnHeight = parseFloat(lnHeightStr, 10);\n\n    // Revert the lineHeight style\n    if (_lnHeightStyle) {\n      node.style.lineHeight = _lnHeightStyle;\n    } else {\n      delete node.style.lineHeight;\n    }\n  }\n\n  // If the lineHeight is in `pt`, convert it to pixels (4px for 3pt)\n  // DEV: `em` units are converted to `pt` in IE6\n  // Conversion ratio from https://developer.mozilla.org/en-US/docs/Web/CSS/length\n  if (lnHeightStr.indexOf('pt') !== -1) {\n    lnHeight *= 4;\n    lnHeight /= 3;\n  // Otherwise, if the lineHeight is in `mm`, convert it to pixels (96px for 25.4mm)\n  } else if (lnHeightStr.indexOf('mm') !== -1) {\n    lnHeight *= 96;\n    lnHeight /= 25.4;\n  // Otherwise, if the lineHeight is in `cm`, convert it to pixels (96px for 2.54cm)\n  } else if (lnHeightStr.indexOf('cm') !== -1) {\n    lnHeight *= 96;\n    lnHeight /= 2.54;\n  // Otherwise, if the lineHeight is in `in`, convert it to pixels (96px for 1in)\n  } else if (lnHeightStr.indexOf('in') !== -1) {\n    lnHeight *= 96;\n  // Otherwise, if the lineHeight is in `pc`, convert it to pixels (12pt for 1pc)\n  } else if (lnHeightStr.indexOf('pc') !== -1) {\n    lnHeight *= 16;\n  }\n\n  // Continue our computation\n  lnHeight = Math.round(lnHeight);\n\n  // If the line-height is \"normal\", calculate by font-size\n  if (lnHeightStr === 'normal') {\n    // Create a temporary node\n    var nodeName = node.nodeName;\n    var _node = document.createElement(nodeName);\n    _node.innerHTML = '&nbsp;';\n\n    // If we have a text area, reset it to only 1 row\n    // https://github.com/twolfson/line-height/issues/4\n    if (nodeName.toUpperCase() === 'TEXTAREA') {\n      _node.setAttribute('rows', '1');\n    }\n\n    // Set the font-size of the element\n    var fontSizeStr = computedStyle(node, 'font-size');\n    _node.style.fontSize = fontSizeStr;\n\n    // Remove default padding/border which can affect offset height\n    // https://github.com/twolfson/line-height/issues/4\n    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetHeight\n    _node.style.padding = '0px';\n    _node.style.border = '0px';\n\n    // Append it to the body\n    var body = document.body;\n    body.appendChild(_node);\n\n    // Assume the line height of the element is the height\n    var height = _node.offsetHeight;\n    lnHeight = height;\n\n    // Remove our child from the DOM\n    body.removeChild(_node);\n  }\n\n  // Return the calculated height\n  return lnHeight;\n}\n\n// Export lineHeight\nmodule.exports = lineHeight;\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\n// This code has been refactored for 140 bytes\n// You can see the original here: https://github.com/twolfson/computedStyle/blob/04cd1da2e30fa45844f95f5cb1ac898e9b9ef050/lib/computedStyle.js\nvar computedStyle = function (el, prop, getComputedStyle) {\n  getComputedStyle = window.getComputedStyle;\n\n  // In one fell swoop\n  return (\n    // If we have getComputedStyle\n    getComputedStyle ?\n      // Query it\n      // TODO: From CSS-Query notes, we might need (node, null) for FF\n      getComputedStyle(el) :\n\n    // Otherwise, we are in IE and use currentStyle\n      el.currentStyle\n  )[\n    // Switch to camelCase for CSSOM\n    // DEV: Grabbed from jQuery\n    // https://github.com/jquery/jquery/blob/1.9-stable/src/css.js#L191-L194\n    // https://github.com/jquery/jquery/blob/1.9-stable/src/core.js#L593-L597\n    prop.replace(/-(\\w)/gi, function (word, letter) {\n      return letter.toUpperCase();\n    })\n  ];\n};\n\nmodule.exports = computedStyle;\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {/**\r\n * A collection of shims that provide minimal functionality of the ES6 collections.\r\n *\r\n * These implementations are not meant to be used outside of the ResizeObserver\r\n * modules as they cover only a limited range of use cases.\r\n */\n/* eslint-disable require-jsdoc, valid-jsdoc */\nvar MapShim = (function () {\n    if (typeof Map !== 'undefined') {\n        return Map;\n    }\n\n    /**\r\n     * Returns index in provided array that matches the specified key.\r\n     *\r\n     * @param {Array<Array>} arr\r\n     * @param {*} key\r\n     * @returns {number}\r\n     */\n    function getIndex(arr, key) {\n        var result = -1;\n\n        arr.some(function (entry, index) {\n            if (entry[0] === key) {\n                result = index;\n\n                return true;\n            }\n\n            return false;\n        });\n\n        return result;\n    }\n\n    return (function () {\n        function anonymous() {\n            this.__entries__ = [];\n        }\n\n        var prototypeAccessors = { size: { configurable: true } };\n\n        /**\r\n         * @returns {boolean}\r\n         */\n        prototypeAccessors.size.get = function () {\n            return this.__entries__.length;\n        };\n\n        /**\r\n         * @param {*} key\r\n         * @returns {*}\r\n         */\n        anonymous.prototype.get = function (key) {\n            var index = getIndex(this.__entries__, key);\n            var entry = this.__entries__[index];\n\n            return entry && entry[1];\n        };\n\n        /**\r\n         * @param {*} key\r\n         * @param {*} value\r\n         * @returns {void}\r\n         */\n        anonymous.prototype.set = function (key, value) {\n            var index = getIndex(this.__entries__, key);\n\n            if (~index) {\n                this.__entries__[index][1] = value;\n            } else {\n                this.__entries__.push([key, value]);\n            }\n        };\n\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\n        anonymous.prototype.delete = function (key) {\n            var entries = this.__entries__;\n            var index = getIndex(entries, key);\n\n            if (~index) {\n                entries.splice(index, 1);\n            }\n        };\n\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\n        anonymous.prototype.has = function (key) {\n            return !!~getIndex(this.__entries__, key);\n        };\n\n        /**\r\n         * @returns {void}\r\n         */\n        anonymous.prototype.clear = function () {\n            this.__entries__.splice(0);\n        };\n\n        /**\r\n         * @param {Function} callback\r\n         * @param {*} [ctx=null]\r\n         * @returns {void}\r\n         */\n        anonymous.prototype.forEach = function (callback, ctx) {\n            var this$1 = this;\n            if ( ctx === void 0 ) ctx = null;\n\n            for (var i = 0, list = this$1.__entries__; i < list.length; i += 1) {\n                var entry = list[i];\n\n                callback.call(ctx, entry[1], entry[0]);\n            }\n        };\n\n        Object.defineProperties( anonymous.prototype, prototypeAccessors );\n\n        return anonymous;\n    }());\n})();\n\n/**\r\n * Detects whether window and document objects are available in current environment.\r\n */\nvar isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;\n\n// Returns global object of a current environment.\nvar global$1 = (function () {\n    if (typeof global !== 'undefined' && global.Math === Math) {\n        return global;\n    }\n\n    if (typeof self !== 'undefined' && self.Math === Math) {\n        return self;\n    }\n\n    if (typeof window !== 'undefined' && window.Math === Math) {\n        return window;\n    }\n\n    // eslint-disable-next-line no-new-func\n    return Function('return this')();\n})();\n\n/**\r\n * A shim for the requestAnimationFrame which falls back to the setTimeout if\r\n * first one is not supported.\r\n *\r\n * @returns {number} Requests' identifier.\r\n */\nvar requestAnimationFrame$1 = (function () {\n    if (typeof requestAnimationFrame === 'function') {\n        // It's required to use a bounded function because IE sometimes throws\n        // an \"Invalid calling object\" error if rAF is invoked without the global\n        // object on the left hand side.\n        return requestAnimationFrame.bind(global$1);\n    }\n\n    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };\n})();\n\n// Defines minimum timeout before adding a trailing call.\nvar trailingTimeout = 2;\n\n/**\r\n * Creates a wrapper function which ensures that provided callback will be\r\n * invoked only once during the specified delay period.\r\n *\r\n * @param {Function} callback - Function to be invoked after the delay period.\r\n * @param {number} delay - Delay after which to invoke callback.\r\n * @returns {Function}\r\n */\nvar throttle = function (callback, delay) {\n    var leadingCall = false,\n        trailingCall = false,\n        lastCallTime = 0;\n\n    /**\r\n     * Invokes the original callback function and schedules new invocation if\r\n     * the \"proxy\" was called during current request.\r\n     *\r\n     * @returns {void}\r\n     */\n    function resolvePending() {\n        if (leadingCall) {\n            leadingCall = false;\n\n            callback();\n        }\n\n        if (trailingCall) {\n            proxy();\n        }\n    }\n\n    /**\r\n     * Callback invoked after the specified delay. It will further postpone\r\n     * invocation of the original function delegating it to the\r\n     * requestAnimationFrame.\r\n     *\r\n     * @returns {void}\r\n     */\n    function timeoutCallback() {\n        requestAnimationFrame$1(resolvePending);\n    }\n\n    /**\r\n     * Schedules invocation of the original function.\r\n     *\r\n     * @returns {void}\r\n     */\n    function proxy() {\n        var timeStamp = Date.now();\n\n        if (leadingCall) {\n            // Reject immediately following calls.\n            if (timeStamp - lastCallTime < trailingTimeout) {\n                return;\n            }\n\n            // Schedule new call to be in invoked when the pending one is resolved.\n            // This is important for \"transitions\" which never actually start\n            // immediately so there is a chance that we might miss one if change\n            // happens amids the pending invocation.\n            trailingCall = true;\n        } else {\n            leadingCall = true;\n            trailingCall = false;\n\n            setTimeout(timeoutCallback, delay);\n        }\n\n        lastCallTime = timeStamp;\n    }\n\n    return proxy;\n};\n\n// Minimum delay before invoking the update of observers.\nvar REFRESH_DELAY = 20;\n\n// A list of substrings of CSS properties used to find transition events that\n// might affect dimensions of observed elements.\nvar transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];\n\n// Check if MutationObserver is available.\nvar mutationObserverSupported = typeof MutationObserver !== 'undefined';\n\n/**\r\n * Singleton controller class which handles updates of ResizeObserver instances.\r\n */\nvar ResizeObserverController = function() {\n    this.connected_ = false;\n    this.mutationEventsAdded_ = false;\n    this.mutationsObserver_ = null;\n    this.observers_ = [];\n\n    this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);\n    this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);\n};\n\n/**\r\n * Adds observer to observers list.\r\n *\r\n * @param {ResizeObserverSPI} observer - Observer to be added.\r\n * @returns {void}\r\n */\n\n\n/**\r\n * Holds reference to the controller's instance.\r\n *\r\n * @private {ResizeObserverController}\r\n */\n\n\n/**\r\n * Keeps reference to the instance of MutationObserver.\r\n *\r\n * @private {MutationObserver}\r\n */\n\n/**\r\n * Indicates whether DOM listeners have been added.\r\n *\r\n * @private {boolean}\r\n */\nResizeObserverController.prototype.addObserver = function (observer) {\n    if (!~this.observers_.indexOf(observer)) {\n        this.observers_.push(observer);\n    }\n\n    // Add listeners if they haven't been added yet.\n    if (!this.connected_) {\n        this.connect_();\n    }\n};\n\n/**\r\n * Removes observer from observers list.\r\n *\r\n * @param {ResizeObserverSPI} observer - Observer to be removed.\r\n * @returns {void}\r\n */\nResizeObserverController.prototype.removeObserver = function (observer) {\n    var observers = this.observers_;\n    var index = observers.indexOf(observer);\n\n    // Remove observer if it's present in registry.\n    if (~index) {\n        observers.splice(index, 1);\n    }\n\n    // Remove listeners if controller has no connected observers.\n    if (!observers.length && this.connected_) {\n        this.disconnect_();\n    }\n};\n\n/**\r\n * Invokes the update of observers. It will continue running updates insofar\r\n * it detects changes.\r\n *\r\n * @returns {void}\r\n */\nResizeObserverController.prototype.refresh = function () {\n    var changesDetected = this.updateObservers_();\n\n    // Continue running updates if changes have been detected as there might\n    // be future ones caused by CSS transitions.\n    if (changesDetected) {\n        this.refresh();\n    }\n};\n\n/**\r\n * Updates every observer from observers list and notifies them of queued\r\n * entries.\r\n *\r\n * @private\r\n * @returns {boolean} Returns \"true\" if any observer has detected changes in\r\n *  dimensions of it's elements.\r\n */\nResizeObserverController.prototype.updateObservers_ = function () {\n    // Collect observers that have active observations.\n    var activeObservers = this.observers_.filter(function (observer) {\n        return observer.gatherActive(), observer.hasActive();\n    });\n\n    // Deliver notifications in a separate cycle in order to avoid any\n    // collisions between observers, e.g. when multiple instances of\n    // ResizeObserver are tracking the same element and the callback of one\n    // of them changes content dimensions of the observed target. Sometimes\n    // this may result in notifications being blocked for the rest of observers.\n    activeObservers.forEach(function (observer) { return observer.broadcastActive(); });\n\n    return activeObservers.length > 0;\n};\n\n/**\r\n * Initializes DOM listeners.\r\n *\r\n * @private\r\n * @returns {void}\r\n */\nResizeObserverController.prototype.connect_ = function () {\n    // Do nothing if running in a non-browser environment or if listeners\n    // have been already added.\n    if (!isBrowser || this.connected_) {\n        return;\n    }\n\n    // Subscription to the \"Transitionend\" event is used as a workaround for\n    // delayed transitions. This way it's possible to capture at least the\n    // final state of an element.\n    document.addEventListener('transitionend', this.onTransitionEnd_);\n\n    window.addEventListener('resize', this.refresh);\n\n    if (mutationObserverSupported) {\n        this.mutationsObserver_ = new MutationObserver(this.refresh);\n\n        this.mutationsObserver_.observe(document, {\n            attributes: true,\n            childList: true,\n            characterData: true,\n            subtree: true\n        });\n    } else {\n        document.addEventListener('DOMSubtreeModified', this.refresh);\n\n        this.mutationEventsAdded_ = true;\n    }\n\n    this.connected_ = true;\n};\n\n/**\r\n * Removes DOM listeners.\r\n *\r\n * @private\r\n * @returns {void}\r\n */\nResizeObserverController.prototype.disconnect_ = function () {\n    // Do nothing if running in a non-browser environment or if listeners\n    // have been already removed.\n    if (!isBrowser || !this.connected_) {\n        return;\n    }\n\n    document.removeEventListener('transitionend', this.onTransitionEnd_);\n    window.removeEventListener('resize', this.refresh);\n\n    if (this.mutationsObserver_) {\n        this.mutationsObserver_.disconnect();\n    }\n\n    if (this.mutationEventsAdded_) {\n        document.removeEventListener('DOMSubtreeModified', this.refresh);\n    }\n\n    this.mutationsObserver_ = null;\n    this.mutationEventsAdded_ = false;\n    this.connected_ = false;\n};\n\n/**\r\n * \"Transitionend\" event handler.\r\n *\r\n * @private\r\n * @param {TransitionEvent} event\r\n * @returns {void}\r\n */\nResizeObserverController.prototype.onTransitionEnd_ = function (ref) {\n        var propertyName = ref.propertyName; if ( propertyName === void 0 ) propertyName = '';\n\n    // Detect whether transition may affect dimensions of an element.\n    var isReflowProperty = transitionKeys.some(function (key) {\n        return !!~propertyName.indexOf(key);\n    });\n\n    if (isReflowProperty) {\n        this.refresh();\n    }\n};\n\n/**\r\n * Returns instance of the ResizeObserverController.\r\n *\r\n * @returns {ResizeObserverController}\r\n */\nResizeObserverController.getInstance = function () {\n    if (!this.instance_) {\n        this.instance_ = new ResizeObserverController();\n    }\n\n    return this.instance_;\n};\n\nResizeObserverController.instance_ = null;\n\n/**\r\n * Defines non-writable/enumerable properties of the provided target object.\r\n *\r\n * @param {Object} target - Object for which to define properties.\r\n * @param {Object} props - Properties to be defined.\r\n * @returns {Object} Target object.\r\n */\nvar defineConfigurable = (function (target, props) {\n    for (var i = 0, list = Object.keys(props); i < list.length; i += 1) {\n        var key = list[i];\n\n        Object.defineProperty(target, key, {\n            value: props[key],\n            enumerable: false,\n            writable: false,\n            configurable: true\n        });\n    }\n\n    return target;\n});\n\n/**\r\n * Returns the global object associated with provided element.\r\n *\r\n * @param {Object} target\r\n * @returns {Object}\r\n */\nvar getWindowOf = (function (target) {\n    // Assume that the element is an instance of Node, which means that it\n    // has the \"ownerDocument\" property from which we can retrieve a\n    // corresponding global object.\n    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;\n\n    // Return the local global object if it's not possible extract one from\n    // provided element.\n    return ownerGlobal || global$1;\n});\n\n// Placeholder of an empty content rectangle.\nvar emptyRect = createRectInit(0, 0, 0, 0);\n\n/**\r\n * Converts provided string to a number.\r\n *\r\n * @param {number|string} value\r\n * @returns {number}\r\n */\nfunction toFloat(value) {\n    return parseFloat(value) || 0;\n}\n\n/**\r\n * Extracts borders size from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @param {...string} positions - Borders positions (top, right, ...)\r\n * @returns {number}\r\n */\nfunction getBordersSize(styles) {\n    var positions = [], len = arguments.length - 1;\n    while ( len-- > 0 ) positions[ len ] = arguments[ len + 1 ];\n\n    return positions.reduce(function (size, position) {\n        var value = styles['border-' + position + '-width'];\n\n        return size + toFloat(value);\n    }, 0);\n}\n\n/**\r\n * Extracts paddings sizes from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @returns {Object} Paddings box.\r\n */\nfunction getPaddings(styles) {\n    var positions = ['top', 'right', 'bottom', 'left'];\n    var paddings = {};\n\n    for (var i = 0, list = positions; i < list.length; i += 1) {\n        var position = list[i];\n\n        var value = styles['padding-' + position];\n\n        paddings[position] = toFloat(value);\n    }\n\n    return paddings;\n}\n\n/**\r\n * Calculates content rectangle of provided SVG element.\r\n *\r\n * @param {SVGGraphicsElement} target - Element content rectangle of which needs\r\n *      to be calculated.\r\n * @returns {DOMRectInit}\r\n */\nfunction getSVGContentRect(target) {\n    var bbox = target.getBBox();\n\n    return createRectInit(0, 0, bbox.width, bbox.height);\n}\n\n/**\r\n * Calculates content rectangle of provided HTMLElement.\r\n *\r\n * @param {HTMLElement} target - Element for which to calculate the content rectangle.\r\n * @returns {DOMRectInit}\r\n */\nfunction getHTMLElementContentRect(target) {\n    // Client width & height properties can't be\n    // used exclusively as they provide rounded values.\n    var clientWidth = target.clientWidth;\n    var clientHeight = target.clientHeight;\n\n    // By this condition we can catch all non-replaced inline, hidden and\n    // detached elements. Though elements with width & height properties less\n    // than 0.5 will be discarded as well.\n    //\n    // Without it we would need to implement separate methods for each of\n    // those cases and it's not possible to perform a precise and performance\n    // effective test for hidden elements. E.g. even jQuery's ':visible' filter\n    // gives wrong results for elements with width & height less than 0.5.\n    if (!clientWidth && !clientHeight) {\n        return emptyRect;\n    }\n\n    var styles = getWindowOf(target).getComputedStyle(target);\n    var paddings = getPaddings(styles);\n    var horizPad = paddings.left + paddings.right;\n    var vertPad = paddings.top + paddings.bottom;\n\n    // Computed styles of width & height are being used because they are the\n    // only dimensions available to JS that contain non-rounded values. It could\n    // be possible to utilize the getBoundingClientRect if only it's data wasn't\n    // affected by CSS transformations let alone paddings, borders and scroll bars.\n    var width = toFloat(styles.width),\n        height = toFloat(styles.height);\n\n    // Width & height include paddings and borders when the 'border-box' box\n    // model is applied (except for IE).\n    if (styles.boxSizing === 'border-box') {\n        // Following conditions are required to handle Internet Explorer which\n        // doesn't include paddings and borders to computed CSS dimensions.\n        //\n        // We can say that if CSS dimensions + paddings are equal to the \"client\"\n        // properties then it's either IE, and thus we don't need to subtract\n        // anything, or an element merely doesn't have paddings/borders styles.\n        if (Math.round(width + horizPad) !== clientWidth) {\n            width -= getBordersSize(styles, 'left', 'right') + horizPad;\n        }\n\n        if (Math.round(height + vertPad) !== clientHeight) {\n            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;\n        }\n    }\n\n    // Following steps can't be applied to the document's root element as its\n    // client[Width/Height] properties represent viewport area of the window.\n    // Besides, it's as well not necessary as the <html> itself neither has\n    // rendered scroll bars nor it can be clipped.\n    if (!isDocumentElement(target)) {\n        // In some browsers (only in Firefox, actually) CSS width & height\n        // include scroll bars size which can be removed at this step as scroll\n        // bars are the only difference between rounded dimensions + paddings\n        // and \"client\" properties, though that is not always true in Chrome.\n        var vertScrollbar = Math.round(width + horizPad) - clientWidth;\n        var horizScrollbar = Math.round(height + vertPad) - clientHeight;\n\n        // Chrome has a rather weird rounding of \"client\" properties.\n        // E.g. for an element with content width of 314.2px it sometimes gives\n        // the client width of 315px and for the width of 314.7px it may give\n        // 314px. And it doesn't happen all the time. So just ignore this delta\n        // as a non-relevant.\n        if (Math.abs(vertScrollbar) !== 1) {\n            width -= vertScrollbar;\n        }\n\n        if (Math.abs(horizScrollbar) !== 1) {\n            height -= horizScrollbar;\n        }\n    }\n\n    return createRectInit(paddings.left, paddings.top, width, height);\n}\n\n/**\r\n * Checks whether provided element is an instance of the SVGGraphicsElement.\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\nvar isSVGGraphicsElement = (function () {\n    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement\n    // interface.\n    if (typeof SVGGraphicsElement !== 'undefined') {\n        return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };\n    }\n\n    // If it's so, then check that element is at least an instance of the\n    // SVGElement and that it has the \"getBBox\" method.\n    // eslint-disable-next-line no-extra-parens\n    return function (target) { return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === 'function'; };\n})();\n\n/**\r\n * Checks whether provided element is a document element (<html>).\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\nfunction isDocumentElement(target) {\n    return target === getWindowOf(target).document.documentElement;\n}\n\n/**\r\n * Calculates an appropriate content rectangle for provided html or svg element.\r\n *\r\n * @param {Element} target - Element content rectangle of which needs to be calculated.\r\n * @returns {DOMRectInit}\r\n */\nfunction getContentRect(target) {\n    if (!isBrowser) {\n        return emptyRect;\n    }\n\n    if (isSVGGraphicsElement(target)) {\n        return getSVGContentRect(target);\n    }\n\n    return getHTMLElementContentRect(target);\n}\n\n/**\r\n * Creates rectangle with an interface of the DOMRectReadOnly.\r\n * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly\r\n *\r\n * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.\r\n * @returns {DOMRectReadOnly}\r\n */\nfunction createReadOnlyRect(ref) {\n    var x = ref.x;\n    var y = ref.y;\n    var width = ref.width;\n    var height = ref.height;\n\n    // If DOMRectReadOnly is available use it as a prototype for the rectangle.\n    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;\n    var rect = Object.create(Constr.prototype);\n\n    // Rectangle's properties are not writable and non-enumerable.\n    defineConfigurable(rect, {\n        x: x, y: y, width: width, height: height,\n        top: y,\n        right: x + width,\n        bottom: height + y,\n        left: x\n    });\n\n    return rect;\n}\n\n/**\r\n * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.\r\n * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit\r\n *\r\n * @param {number} x - X coordinate.\r\n * @param {number} y - Y coordinate.\r\n * @param {number} width - Rectangle's width.\r\n * @param {number} height - Rectangle's height.\r\n * @returns {DOMRectInit}\r\n */\nfunction createRectInit(x, y, width, height) {\n    return { x: x, y: y, width: width, height: height };\n}\n\n/**\r\n * Class that is responsible for computations of the content rectangle of\r\n * provided DOM element and for keeping track of it's changes.\r\n */\nvar ResizeObservation = function(target) {\n    this.broadcastWidth = 0;\n    this.broadcastHeight = 0;\n    this.contentRect_ = createRectInit(0, 0, 0, 0);\n\n    this.target = target;\n};\n\n/**\r\n * Updates content rectangle and tells whether it's width or height properties\r\n * have changed since the last broadcast.\r\n *\r\n * @returns {boolean}\r\n */\n\n\n/**\r\n * Reference to the last observed content rectangle.\r\n *\r\n * @private {DOMRectInit}\r\n */\n\n\n/**\r\n * Broadcasted width of content rectangle.\r\n *\r\n * @type {number}\r\n */\nResizeObservation.prototype.isActive = function () {\n    var rect = getContentRect(this.target);\n\n    this.contentRect_ = rect;\n\n    return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;\n};\n\n/**\r\n * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data\r\n * from the corresponding properties of the last observed content rectangle.\r\n *\r\n * @returns {DOMRectInit} Last observed content rectangle.\r\n */\nResizeObservation.prototype.broadcastRect = function () {\n    var rect = this.contentRect_;\n\n    this.broadcastWidth = rect.width;\n    this.broadcastHeight = rect.height;\n\n    return rect;\n};\n\nvar ResizeObserverEntry = function(target, rectInit) {\n    var contentRect = createReadOnlyRect(rectInit);\n\n    // According to the specification following properties are not writable\n    // and are also not enumerable in the native implementation.\n    //\n    // Property accessors are not being used as they'd require to define a\n    // private WeakMap storage which may cause memory leaks in browsers that\n    // don't support this type of collections.\n    defineConfigurable(this, { target: target, contentRect: contentRect });\n};\n\nvar ResizeObserverSPI = function(callback, controller, callbackCtx) {\n    this.activeObservations_ = [];\n    this.observations_ = new MapShim();\n\n    if (typeof callback !== 'function') {\n        throw new TypeError('The callback provided as parameter 1 is not a function.');\n    }\n\n    this.callback_ = callback;\n    this.controller_ = controller;\n    this.callbackCtx_ = callbackCtx;\n};\n\n/**\r\n * Starts observing provided element.\r\n *\r\n * @param {Element} target - Element to be observed.\r\n * @returns {void}\r\n */\n\n\n/**\r\n * Registry of the ResizeObservation instances.\r\n *\r\n * @private {Map<Element, ResizeObservation>}\r\n */\n\n\n/**\r\n * Public ResizeObserver instance which will be passed to the callback\r\n * function and used as a value of it's \"this\" binding.\r\n *\r\n * @private {ResizeObserver}\r\n */\n\n/**\r\n * Collection of resize observations that have detected changes in dimensions\r\n * of elements.\r\n *\r\n * @private {Array<ResizeObservation>}\r\n */\nResizeObserverSPI.prototype.observe = function (target) {\n    if (!arguments.length) {\n        throw new TypeError('1 argument required, but only 0 present.');\n    }\n\n    // Do nothing if current environment doesn't have the Element interface.\n    if (typeof Element === 'undefined' || !(Element instanceof Object)) {\n        return;\n    }\n\n    if (!(target instanceof getWindowOf(target).Element)) {\n        throw new TypeError('parameter 1 is not of type \"Element\".');\n    }\n\n    var observations = this.observations_;\n\n    // Do nothing if element is already being observed.\n    if (observations.has(target)) {\n        return;\n    }\n\n    observations.set(target, new ResizeObservation(target));\n\n    this.controller_.addObserver(this);\n\n    // Force the update of observations.\n    this.controller_.refresh();\n};\n\n/**\r\n * Stops observing provided element.\r\n *\r\n * @param {Element} target - Element to stop observing.\r\n * @returns {void}\r\n */\nResizeObserverSPI.prototype.unobserve = function (target) {\n    if (!arguments.length) {\n        throw new TypeError('1 argument required, but only 0 present.');\n    }\n\n    // Do nothing if current environment doesn't have the Element interface.\n    if (typeof Element === 'undefined' || !(Element instanceof Object)) {\n        return;\n    }\n\n    if (!(target instanceof getWindowOf(target).Element)) {\n        throw new TypeError('parameter 1 is not of type \"Element\".');\n    }\n\n    var observations = this.observations_;\n\n    // Do nothing if element is not being observed.\n    if (!observations.has(target)) {\n        return;\n    }\n\n    observations.delete(target);\n\n    if (!observations.size) {\n        this.controller_.removeObserver(this);\n    }\n};\n\n/**\r\n * Stops observing all elements.\r\n *\r\n * @returns {void}\r\n */\nResizeObserverSPI.prototype.disconnect = function () {\n    this.clearActive();\n    this.observations_.clear();\n    this.controller_.removeObserver(this);\n};\n\n/**\r\n * Collects observation instances the associated element of which has changed\r\n * it's content rectangle.\r\n *\r\n * @returns {void}\r\n */\nResizeObserverSPI.prototype.gatherActive = function () {\n        var this$1 = this;\n\n    this.clearActive();\n\n    this.observations_.forEach(function (observation) {\n        if (observation.isActive()) {\n            this$1.activeObservations_.push(observation);\n        }\n    });\n};\n\n/**\r\n * Invokes initial callback function with a list of ResizeObserverEntry\r\n * instances collected from active resize observations.\r\n *\r\n * @returns {void}\r\n */\nResizeObserverSPI.prototype.broadcastActive = function () {\n    // Do nothing if observer doesn't have active observations.\n    if (!this.hasActive()) {\n        return;\n    }\n\n    var ctx = this.callbackCtx_;\n\n    // Create ResizeObserverEntry instance for every active observation.\n    var entries = this.activeObservations_.map(function (observation) {\n        return new ResizeObserverEntry(observation.target, observation.broadcastRect());\n    });\n\n    this.callback_.call(ctx, entries, ctx);\n    this.clearActive();\n};\n\n/**\r\n * Clears the collection of active observations.\r\n *\r\n * @returns {void}\r\n */\nResizeObserverSPI.prototype.clearActive = function () {\n    this.activeObservations_.splice(0);\n};\n\n/**\r\n * Tells whether observer has active observations.\r\n *\r\n * @returns {boolean}\r\n */\nResizeObserverSPI.prototype.hasActive = function () {\n    return this.activeObservations_.length > 0;\n};\n\n// Registry of internal observers. If WeakMap is not available use current shim\n// for the Map collection as it has all required methods and because WeakMap\n// can't be fully polyfilled anyway.\nvar observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();\n\n/**\r\n * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation\r\n * exposing only those methods and properties that are defined in the spec.\r\n */\nvar ResizeObserver = function(callback) {\n    if (!(this instanceof ResizeObserver)) {\n        throw new TypeError('Cannot call a class as a function.');\n    }\n    if (!arguments.length) {\n        throw new TypeError('1 argument required, but only 0 present.');\n    }\n\n    var controller = ResizeObserverController.getInstance();\n    var observer = new ResizeObserverSPI(callback, controller, this);\n\n    observers.set(this, observer);\n};\n\n// Expose public methods of ResizeObserver.\n['observe', 'unobserve', 'disconnect'].forEach(function (method) {\n    ResizeObserver.prototype[method] = function () {\n        return (ref = observers.get(this))[method].apply(ref, arguments);\n        var ref;\n    };\n});\n\nvar index = (function () {\n    // Export existing implementation if available.\n    if (typeof global$1.ResizeObserver !== 'undefined') {\n        return global$1.ResizeObserver;\n    }\n\n    return ResizeObserver;\n})();\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (index);\n\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(6)))\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar TOKENIZE_POLICY = {\n  characters: {\n    tokenizeString: null,\n    isAtomic: function isAtomic(str) {\n      return str.length <= 1;\n    }\n  },\n  words: {\n    tokenizeString: function tokenizeString(str) {\n      return str.match(/(\\s*\\S[\\S\\xA0]*)/g);\n    },\n    isAtomic: function isAtomic(str) {\n      return (/^\\s*[\\S\\xA0]*\\s*$/.test(str)\n      );\n    }\n  }\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (TOKENIZE_POLICY);\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// react-truncate-markup.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 4b50cb917cb1bf04cc02","import React from 'react';\nimport PropTypes from 'prop-types';\nimport getLineHeight from 'line-height';\nimport ResizeObserver from 'resize-observer-polyfill';\nimport TOKENIZE_POLICY from './tokenize-rules';\n\nconst SPLIT = {\n  LEFT: true,\n  RIGHT: false,\n};\n\nconst toString = (node, string = '') => {\n  if (!node) {\n    return string;\n  } else if (typeof node === 'string') {\n    return string + node;\n  } else if (Array.isArray(node)) {\n    let newString = string;\n    node.forEach(child => {\n      newString = toString(child, newString);\n    });\n\n    return newString;\n  }\n\n  return toString(node.props.children, string);\n};\n\nconst getTokenizePolicyByProp = tokenize => {\n  if (process.env.NODE_ENV !== 'production' && !TOKENIZE_POLICY[tokenize]) {\n    /* eslint-disable no-console */\n    console.warn(\n      `ReactTruncateMarkup: Unknown option for prop 'tokenize': '${tokenize}'. Option 'characters' will be used instead.`,\n    );\n    /* eslint-enable */\n  }\n\n  return TOKENIZE_POLICY[tokenize] || TOKENIZE_POLICY.characters;\n};\n\nconst cloneWithChildren = (node, children, isRootEl, level) => ({\n  ...node,\n  props: {\n    ...node.props,\n    style: {\n      ...node.props.style,\n      ...(isRootEl\n        ? {\n            // root element cannot be an inline element because of the line calculation\n            display: (node.props.style || {}).display || 'block',\n          }\n        : level === 2\n          ? {\n              // level 2 elements (direct children of the root element) need to be inline because of the ellipsis.\n              // if level 2 element was a block element, ellipsis would get rendered on a new line, breaking the max number of lines\n              display: (node.props.style || {}).display || 'inline-block',\n            }\n          : {}),\n    },\n    children,\n  },\n});\n\nconst validateTree = node => {\n  if (typeof node === 'string') {\n    return true;\n  } else if (typeof node.type === 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      /* eslint-disable no-console */\n      console.error(\n        `ReactTruncateMarkup tried to render <${node.type\n          .name} />, but truncating React components is not supported, the full content is rendered instead. Only DOM elements are supported.`,\n      );\n      /* eslint-enable */\n    }\n\n    return false;\n  }\n\n  if (node.props.children) {\n    if (Array.isArray(node.props.children)) {\n      return node.props.children.reduce(\n        (isValid, child) => isValid && validateTree(child),\n        true,\n      );\n    }\n\n    return validateTree(node.props.children);\n  }\n\n  return true;\n};\n\nexport default class TruncateMarkup extends React.Component {\n  static propTypes = {\n    children: PropTypes.element.isRequired,\n    lines: PropTypes.number,\n    ellipsis: PropTypes.oneOfType([\n      PropTypes.element,\n      PropTypes.string,\n      PropTypes.func,\n    ]),\n    lineHeight: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n    onTruncate: PropTypes.func,\n    // eslint-disable-next-line\n    onAfterTruncate: (props, propName, componentName) => {\n      if (props[propName]) {\n        return new Error(\n          `${componentName}: Setting \\`onAfterTruncate\\` prop is deprecated, use \\`onTruncate\\` instead.`,\n        );\n      }\n    },\n    tokenize: PropTypes.oneOf(['characters', 'words']),\n  };\n\n  static defaultProps = {\n    lines: 1,\n    ellipsis: '...',\n    lineHeight: '',\n    onTruncate: () => {},\n    tokenize: 'characters',\n  };\n\n  state = {\n    text: this.childrenElementWithRef(this.props.children),\n  };\n\n  isValid = validateTree(this.props.children);\n  lineHeight = null;\n  splitDirectionSeq = [];\n  shouldTruncate = true;\n  wasLastCharTested = false;\n  endFound = false;\n  latestThatFits = null;\n  origText = null;\n  onTruncateCalled = false;\n  policy = null;\n\n  componentDidMount() {\n    if (!this.isValid) {\n      return;\n    }\n\n    this.origText = this.state.text;\n\n    // get the computed line-height of the parent element\n    // it'll be used for determining whether the text fits the container or not\n    this.lineHeight = this.props.lineHeight || getLineHeight(this.el);\n    this.policy = getTokenizePolicyByProp(this.props.tokenize);\n    this.truncate();\n\n    this.handleResize();\n  }\n\n  UNSAFE_componentWillReceiveProps(nextProps) {\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n    }\n    this.policy = getTokenizePolicyByProp(nextProps.tokenize);\n    this.shouldTruncate = false;\n    this.latestThatFits = null;\n    this.isValid = validateTree(nextProps.children);\n\n    this.setState(\n      {\n        text: this.childrenElementWithRef(nextProps.children),\n      },\n      () => {\n        if (!this.isValid) {\n          return;\n        }\n\n        this.origText = this.state.text;\n        this.lineHeight = nextProps.lineHeight || getLineHeight(this.el);\n        this.shouldTruncate = true;\n        this.truncate();\n\n        this.handleResize();\n      },\n    );\n  }\n\n  componentDidUpdate() {\n    if (this.shouldTruncate === false || this.isValid === false) {\n      return;\n    }\n\n    if (this.endFound) {\n      // we've found the end where we cannot split the text further\n      // that means we've already found the max subtree that fits the container\n      // so we are rendering that\n      if (this.state.text !== this.latestThatFits) {\n        /* eslint-disable react/no-did-update-set-state */\n        this.setState({\n          text: this.latestThatFits,\n        });\n\n        return;\n        /* eslint-enable */\n      }\n\n      this.onTruncate(/* wasTruncated */ true);\n\n      return;\n    }\n\n    if (this.splitDirectionSeq.length) {\n      if (this.fits()) {\n        this.latestThatFits = this.state.text;\n        // we've found a subtree that fits the container\n        // but we need to check if we didn't cut too much of it off\n        // so we are changing the last splitting decision from splitting and going left\n        // to splitting and going right\n        this.splitDirectionSeq.splice(\n          this.splitDirectionSeq.length - 1,\n          1,\n          SPLIT.RIGHT,\n          SPLIT.LEFT,\n        );\n      } else {\n        this.splitDirectionSeq.push(SPLIT.LEFT);\n      }\n\n      this.tryToFit(this.origText, this.splitDirectionSeq);\n    }\n  }\n\n  componentWillUnmount() {\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n    }\n\n    this.lineHeight = null;\n    this.origText = null;\n    this.latestThatFits = null;\n    this.splitDirectionSeq = [];\n  }\n\n  onTruncate = wasTruncated => {\n    if (!this.onTruncateCalled) {\n      this.onTruncateCalled = true;\n      this.props.onTruncate(wasTruncated);\n    }\n  };\n\n  handleResize = () => {\n    /* Wrapper element resize handing */\n    let initialRender = true;\n\n    this.resizeObserver = new ResizeObserver(() => {\n      if (initialRender) {\n        // ResizeObserer cb is called on initial render too so we are skipping here\n        initialRender = false;\n      } else {\n        // wrapper element has been resized, recalculating with the original text\n        this.shouldTruncate = false;\n        this.latestThatFits = null;\n\n        this.setState(\n          {\n            text: this.origText,\n          },\n          () => {\n            this.shouldTruncate = true;\n            this.onTruncateCalled = false;\n            this.truncate();\n          },\n        );\n      }\n    });\n\n    this.resizeObserver.observe(this.el);\n  };\n\n  truncate() {\n    if (this.fits()) {\n      // the whole text fits on the first try, no need to do anything else\n      this.shouldTruncate = false;\n      this.onTruncate(/* wasTruncated */ false);\n\n      return;\n    }\n\n    this.truncateOriginalText();\n  }\n\n  childrenElementWithRef(children) {\n    const child = React.Children.only(children);\n\n    return React.cloneElement(child, { ref: el => (this.el = el) });\n  }\n\n  truncateOriginalText() {\n    this.endFound = false;\n    this.splitDirectionSeq = [SPLIT.LEFT];\n    this.wasLastCharTested = false;\n\n    this.tryToFit(this.origText, this.splitDirectionSeq);\n  }\n\n  /**\n   * Splits rootEl based on instructions and updates React's state with the returned element\n   * After React rerenders the new text, we'll check if the new text fits in componentDidUpdate\n   * @param  {ReactElement} rootEl - the original children element\n   * @param  {Array} splitDirections - list of SPLIT.RIGHT/LEFT instructions\n   */\n  tryToFit(rootEl, splitDirections) {\n    if (!rootEl.props.children) {\n      // no markup in container\n      return;\n    }\n\n    const newRootEl = this.split(rootEl, splitDirections, /* isRootEl */ true);\n\n    let ellipsis =\n      typeof this.props.ellipsis === 'function'\n        ? this.props.ellipsis(newRootEl)\n        : this.props.ellipsis;\n\n    ellipsis =\n      typeof ellipsis === 'object'\n        ? React.cloneElement(ellipsis, { key: 'ellipsis' })\n        : ellipsis;\n\n    const newChildren = newRootEl.props.children;\n    const newChildrenWithEllipsis = Array.isArray(newChildren)\n      ? [...newChildren, ellipsis]\n      : [newChildren, ellipsis];\n\n    // edge case tradeoff EC#1 - on initial render it doesn't fit in the requested number of lines (1) so it starts truncating\n    // - because of truncating and the ellipsis position, div#lvl2 will have display set to 'inline-block',\n    //   causing the whole body to fit in 1 line again\n    // - if that happens, ellipsis is not needed anymore as the whole body is rendered\n    // - NOTE this could be fixed by checking for this exact case and handling it separately so it renders <div>foo {ellipsis}</div>\n    //\n    // Example:\n    // <TruncateMarkup lines={1}>\n    //   <div>\n    //     foo\n    //     <div id=\"lvl2\">bar</div>\n    //   </div>\n    // </TruncateMarkup>\n    const shouldRenderEllipsis =\n      toString(newChildren) !== toString(this.origText);\n\n    this.setState({\n      text: {\n        ...newRootEl,\n        props: {\n          ...newRootEl.props,\n          style: {\n            wordWrap: 'break-word',\n            ...newRootEl.props.style,\n          },\n          children: shouldRenderEllipsis\n            ? newChildrenWithEllipsis\n            : newChildren,\n        },\n      },\n    });\n  }\n\n  /**\n   * Splits JSX node based on its type\n   * @param  {null|string|Array|Object} node - JSX node\n   * @param  {Array} splitDirections - list of SPLIT.RIGHT/LEFT instructions\n   * @return {null|string|Array|Object} - split JSX node\n   */\n  split(node, splitDirections, isRoot = false, level = 1) {\n    if (!node) {\n      return node;\n    } else if (typeof node === 'string') {\n      return this.splitString(node, splitDirections, level);\n    } else if (Array.isArray(node)) {\n      return this.splitArray(node, splitDirections, level);\n    }\n\n    const newChildren = this.split(\n      node.props.children,\n      splitDirections,\n      /* isRoot */ false,\n      level + 1,\n    );\n\n    return cloneWithChildren(node, newChildren, isRoot, level);\n  }\n\n  splitString(string, splitDirections = [], level) {\n    if (!splitDirections.length) {\n      return string;\n    }\n\n    if (splitDirections.length && this.policy.isAtomic(string)) {\n      // allow for an extra render test with the current character included\n      // in most cases this variation was already tested, but some edge cases require this check\n      // NOTE could be removed once EC#1 is taken care of\n      if (!this.wasLastCharTested) {\n        this.wasLastCharTested = true;\n      } else {\n        // we are trying to split further but we have nowhere to go now\n        // that means we've already found the max subtree that fits the container\n        this.endFound = true;\n      }\n\n      return string;\n    }\n\n    if (this.policy.tokenizeString) {\n      const wordsArray = this.splitArray(\n        this.policy.tokenizeString(string),\n        splitDirections,\n        level,\n      );\n\n      // in order to preserve the input structure\n      return wordsArray.join('');\n    }\n\n    const [splitDirection, ...restSplitDirections] = splitDirections;\n    const pivotIndex = Math.ceil(string.length / 2);\n    const beforeString = string.substring(0, pivotIndex);\n\n    if (splitDirection === SPLIT.LEFT) {\n      return this.splitString(beforeString, restSplitDirections, level);\n    }\n    const afterString = string.substring(pivotIndex);\n\n    return (\n      beforeString + this.splitString(afterString, restSplitDirections, level)\n    );\n  }\n\n  splitArray(array, splitDirections = [], level) {\n    if (!splitDirections.length) {\n      return array;\n    }\n\n    if (array.length === 1) {\n      const [item] = array;\n\n      if (typeof item === 'string') {\n        return [this.splitString(item, splitDirections, level)];\n      }\n      const { children } = item.props;\n\n      const newChildren = this.split(\n        children,\n        splitDirections,\n        /* isRoot */ false,\n        level + 1,\n      );\n\n      return [cloneWithChildren(item, newChildren, /* isRoot */ false, level)];\n    }\n\n    const [splitDirection, ...restSplitDirections] = splitDirections;\n    const pivotIndex = Math.ceil(array.length / 2);\n    const beforeArray = array.slice(0, pivotIndex);\n\n    if (splitDirection === SPLIT.LEFT) {\n      return this.splitArray(beforeArray, restSplitDirections, level);\n    }\n    const afterArray = array.slice(pivotIndex);\n\n    return beforeArray.concat(\n      this.splitArray(afterArray, restSplitDirections, level),\n    );\n  }\n\n  fits() {\n    const { lines: maxLines } = this.props;\n    const { height } = this.el.getBoundingClientRect();\n    const computedLines = Math.round(height / parseFloat(this.lineHeight));\n\n    if (process.env.NODE_ENV !== 'production' && computedLines <= 0) {\n      /* eslint-disable no-console */\n      console.warn(\n        `ReactTruncateMarkup: number of currently rendered lines: ${computedLines}, not truncating...\n  It may be caused by target element not being visible at the time of computation.`,\n      );\n      /* eslint-enable */\n    }\n\n    return maxLines >= computedLines;\n  }\n\n  render() {\n    return this.state.text;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","module.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"root\":\"React\",\"commonjs2\":\"react\",\"commonjs\":\"react\",\"amd\":\"react\"}\n// module id = 2\n// module chunks = 0","// Load in dependencies\nvar computedStyle = require('computed-style');\n\n/**\n * Calculate the `line-height` of a given node\n * @param {HTMLElement} node Element to calculate line height of. Must be in the DOM.\n * @returns {Number} `line-height` of the element in pixels\n */\nfunction lineHeight(node) {\n  // Grab the line-height via style\n  var lnHeightStr = computedStyle(node, 'line-height');\n  var lnHeight = parseFloat(lnHeightStr, 10);\n\n  // If the lineHeight did not contain a unit (i.e. it was numeric), convert it to ems (e.g. '2.3' === '2.3em')\n  if (lnHeightStr === lnHeight + '') {\n    // Save the old lineHeight style and update the em unit to the element\n    var _lnHeightStyle = node.style.lineHeight;\n    node.style.lineHeight = lnHeightStr + 'em';\n\n    // Calculate the em based height\n    lnHeightStr = computedStyle(node, 'line-height');\n    lnHeight = parseFloat(lnHeightStr, 10);\n\n    // Revert the lineHeight style\n    if (_lnHeightStyle) {\n      node.style.lineHeight = _lnHeightStyle;\n    } else {\n      delete node.style.lineHeight;\n    }\n  }\n\n  // If the lineHeight is in `pt`, convert it to pixels (4px for 3pt)\n  // DEV: `em` units are converted to `pt` in IE6\n  // Conversion ratio from https://developer.mozilla.org/en-US/docs/Web/CSS/length\n  if (lnHeightStr.indexOf('pt') !== -1) {\n    lnHeight *= 4;\n    lnHeight /= 3;\n  // Otherwise, if the lineHeight is in `mm`, convert it to pixels (96px for 25.4mm)\n  } else if (lnHeightStr.indexOf('mm') !== -1) {\n    lnHeight *= 96;\n    lnHeight /= 25.4;\n  // Otherwise, if the lineHeight is in `cm`, convert it to pixels (96px for 2.54cm)\n  } else if (lnHeightStr.indexOf('cm') !== -1) {\n    lnHeight *= 96;\n    lnHeight /= 2.54;\n  // Otherwise, if the lineHeight is in `in`, convert it to pixels (96px for 1in)\n  } else if (lnHeightStr.indexOf('in') !== -1) {\n    lnHeight *= 96;\n  // Otherwise, if the lineHeight is in `pc`, convert it to pixels (12pt for 1pc)\n  } else if (lnHeightStr.indexOf('pc') !== -1) {\n    lnHeight *= 16;\n  }\n\n  // Continue our computation\n  lnHeight = Math.round(lnHeight);\n\n  // If the line-height is \"normal\", calculate by font-size\n  if (lnHeightStr === 'normal') {\n    // Create a temporary node\n    var nodeName = node.nodeName;\n    var _node = document.createElement(nodeName);\n    _node.innerHTML = '&nbsp;';\n\n    // If we have a text area, reset it to only 1 row\n    // https://github.com/twolfson/line-height/issues/4\n    if (nodeName.toUpperCase() === 'TEXTAREA') {\n      _node.setAttribute('rows', '1');\n    }\n\n    // Set the font-size of the element\n    var fontSizeStr = computedStyle(node, 'font-size');\n    _node.style.fontSize = fontSizeStr;\n\n    // Remove default padding/border which can affect offset height\n    // https://github.com/twolfson/line-height/issues/4\n    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetHeight\n    _node.style.padding = '0px';\n    _node.style.border = '0px';\n\n    // Append it to the body\n    var body = document.body;\n    body.appendChild(_node);\n\n    // Assume the line height of the element is the height\n    var height = _node.offsetHeight;\n    lnHeight = height;\n\n    // Remove our child from the DOM\n    body.removeChild(_node);\n  }\n\n  // Return the calculated height\n  return lnHeight;\n}\n\n// Export lineHeight\nmodule.exports = lineHeight;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/line-height/lib/line-height.js\n// module id = 3\n// module chunks = 0","// This code has been refactored for 140 bytes\n// You can see the original here: https://github.com/twolfson/computedStyle/blob/04cd1da2e30fa45844f95f5cb1ac898e9b9ef050/lib/computedStyle.js\nvar computedStyle = function (el, prop, getComputedStyle) {\n  getComputedStyle = window.getComputedStyle;\n\n  // In one fell swoop\n  return (\n    // If we have getComputedStyle\n    getComputedStyle ?\n      // Query it\n      // TODO: From CSS-Query notes, we might need (node, null) for FF\n      getComputedStyle(el) :\n\n    // Otherwise, we are in IE and use currentStyle\n      el.currentStyle\n  )[\n    // Switch to camelCase for CSSOM\n    // DEV: Grabbed from jQuery\n    // https://github.com/jquery/jquery/blob/1.9-stable/src/css.js#L191-L194\n    // https://github.com/jquery/jquery/blob/1.9-stable/src/core.js#L593-L597\n    prop.replace(/-(\\w)/gi, function (word, letter) {\n      return letter.toUpperCase();\n    })\n  ];\n};\n\nmodule.exports = computedStyle;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/computed-style/dist/computedStyle.commonjs.js\n// module id = 4\n// module chunks = 0","/**\r\n * A collection of shims that provide minimal functionality of the ES6 collections.\r\n *\r\n * These implementations are not meant to be used outside of the ResizeObserver\r\n * modules as they cover only a limited range of use cases.\r\n */\n/* eslint-disable require-jsdoc, valid-jsdoc */\nvar MapShim = (function () {\n    if (typeof Map !== 'undefined') {\n        return Map;\n    }\n\n    /**\r\n     * Returns index in provided array that matches the specified key.\r\n     *\r\n     * @param {Array<Array>} arr\r\n     * @param {*} key\r\n     * @returns {number}\r\n     */\n    function getIndex(arr, key) {\n        var result = -1;\n\n        arr.some(function (entry, index) {\n            if (entry[0] === key) {\n                result = index;\n\n                return true;\n            }\n\n            return false;\n        });\n\n        return result;\n    }\n\n    return (function () {\n        function anonymous() {\n            this.__entries__ = [];\n        }\n\n        var prototypeAccessors = { size: { configurable: true } };\n\n        /**\r\n         * @returns {boolean}\r\n         */\n        prototypeAccessors.size.get = function () {\n            return this.__entries__.length;\n        };\n\n        /**\r\n         * @param {*} key\r\n         * @returns {*}\r\n         */\n        anonymous.prototype.get = function (key) {\n            var index = getIndex(this.__entries__, key);\n            var entry = this.__entries__[index];\n\n            return entry && entry[1];\n        };\n\n        /**\r\n         * @param {*} key\r\n         * @param {*} value\r\n         * @returns {void}\r\n         */\n        anonymous.prototype.set = function (key, value) {\n            var index = getIndex(this.__entries__, key);\n\n            if (~index) {\n                this.__entries__[index][1] = value;\n            } else {\n                this.__entries__.push([key, value]);\n            }\n        };\n\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\n        anonymous.prototype.delete = function (key) {\n            var entries = this.__entries__;\n            var index = getIndex(entries, key);\n\n            if (~index) {\n                entries.splice(index, 1);\n            }\n        };\n\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\n        anonymous.prototype.has = function (key) {\n            return !!~getIndex(this.__entries__, key);\n        };\n\n        /**\r\n         * @returns {void}\r\n         */\n        anonymous.prototype.clear = function () {\n            this.__entries__.splice(0);\n        };\n\n        /**\r\n         * @param {Function} callback\r\n         * @param {*} [ctx=null]\r\n         * @returns {void}\r\n         */\n        anonymous.prototype.forEach = function (callback, ctx) {\n            var this$1 = this;\n            if ( ctx === void 0 ) ctx = null;\n\n            for (var i = 0, list = this$1.__entries__; i < list.length; i += 1) {\n                var entry = list[i];\n\n                callback.call(ctx, entry[1], entry[0]);\n            }\n        };\n\n        Object.defineProperties( anonymous.prototype, prototypeAccessors );\n\n        return anonymous;\n    }());\n})();\n\n/**\r\n * Detects whether window and document objects are available in current environment.\r\n */\nvar isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;\n\n// Returns global object of a current environment.\nvar global$1 = (function () {\n    if (typeof global !== 'undefined' && global.Math === Math) {\n        return global;\n    }\n\n    if (typeof self !== 'undefined' && self.Math === Math) {\n        return self;\n    }\n\n    if (typeof window !== 'undefined' && window.Math === Math) {\n        return window;\n    }\n\n    // eslint-disable-next-line no-new-func\n    return Function('return this')();\n})();\n\n/**\r\n * A shim for the requestAnimationFrame which falls back to the setTimeout if\r\n * first one is not supported.\r\n *\r\n * @returns {number} Requests' identifier.\r\n */\nvar requestAnimationFrame$1 = (function () {\n    if (typeof requestAnimationFrame === 'function') {\n        // It's required to use a bounded function because IE sometimes throws\n        // an \"Invalid calling object\" error if rAF is invoked without the global\n        // object on the left hand side.\n        return requestAnimationFrame.bind(global$1);\n    }\n\n    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };\n})();\n\n// Defines minimum timeout before adding a trailing call.\nvar trailingTimeout = 2;\n\n/**\r\n * Creates a wrapper function which ensures that provided callback will be\r\n * invoked only once during the specified delay period.\r\n *\r\n * @param {Function} callback - Function to be invoked after the delay period.\r\n * @param {number} delay - Delay after which to invoke callback.\r\n * @returns {Function}\r\n */\nvar throttle = function (callback, delay) {\n    var leadingCall = false,\n        trailingCall = false,\n        lastCallTime = 0;\n\n    /**\r\n     * Invokes the original callback function and schedules new invocation if\r\n     * the \"proxy\" was called during current request.\r\n     *\r\n     * @returns {void}\r\n     */\n    function resolvePending() {\n        if (leadingCall) {\n            leadingCall = false;\n\n            callback();\n        }\n\n        if (trailingCall) {\n            proxy();\n        }\n    }\n\n    /**\r\n     * Callback invoked after the specified delay. It will further postpone\r\n     * invocation of the original function delegating it to the\r\n     * requestAnimationFrame.\r\n     *\r\n     * @returns {void}\r\n     */\n    function timeoutCallback() {\n        requestAnimationFrame$1(resolvePending);\n    }\n\n    /**\r\n     * Schedules invocation of the original function.\r\n     *\r\n     * @returns {void}\r\n     */\n    function proxy() {\n        var timeStamp = Date.now();\n\n        if (leadingCall) {\n            // Reject immediately following calls.\n            if (timeStamp - lastCallTime < trailingTimeout) {\n                return;\n            }\n\n            // Schedule new call to be in invoked when the pending one is resolved.\n            // This is important for \"transitions\" which never actually start\n            // immediately so there is a chance that we might miss one if change\n            // happens amids the pending invocation.\n            trailingCall = true;\n        } else {\n            leadingCall = true;\n            trailingCall = false;\n\n            setTimeout(timeoutCallback, delay);\n        }\n\n        lastCallTime = timeStamp;\n    }\n\n    return proxy;\n};\n\n// Minimum delay before invoking the update of observers.\nvar REFRESH_DELAY = 20;\n\n// A list of substrings of CSS properties used to find transition events that\n// might affect dimensions of observed elements.\nvar transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];\n\n// Check if MutationObserver is available.\nvar mutationObserverSupported = typeof MutationObserver !== 'undefined';\n\n/**\r\n * Singleton controller class which handles updates of ResizeObserver instances.\r\n */\nvar ResizeObserverController = function() {\n    this.connected_ = false;\n    this.mutationEventsAdded_ = false;\n    this.mutationsObserver_ = null;\n    this.observers_ = [];\n\n    this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);\n    this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);\n};\n\n/**\r\n * Adds observer to observers list.\r\n *\r\n * @param {ResizeObserverSPI} observer - Observer to be added.\r\n * @returns {void}\r\n */\n\n\n/**\r\n * Holds reference to the controller's instance.\r\n *\r\n * @private {ResizeObserverController}\r\n */\n\n\n/**\r\n * Keeps reference to the instance of MutationObserver.\r\n *\r\n * @private {MutationObserver}\r\n */\n\n/**\r\n * Indicates whether DOM listeners have been added.\r\n *\r\n * @private {boolean}\r\n */\nResizeObserverController.prototype.addObserver = function (observer) {\n    if (!~this.observers_.indexOf(observer)) {\n        this.observers_.push(observer);\n    }\n\n    // Add listeners if they haven't been added yet.\n    if (!this.connected_) {\n        this.connect_();\n    }\n};\n\n/**\r\n * Removes observer from observers list.\r\n *\r\n * @param {ResizeObserverSPI} observer - Observer to be removed.\r\n * @returns {void}\r\n */\nResizeObserverController.prototype.removeObserver = function (observer) {\n    var observers = this.observers_;\n    var index = observers.indexOf(observer);\n\n    // Remove observer if it's present in registry.\n    if (~index) {\n        observers.splice(index, 1);\n    }\n\n    // Remove listeners if controller has no connected observers.\n    if (!observers.length && this.connected_) {\n        this.disconnect_();\n    }\n};\n\n/**\r\n * Invokes the update of observers. It will continue running updates insofar\r\n * it detects changes.\r\n *\r\n * @returns {void}\r\n */\nResizeObserverController.prototype.refresh = function () {\n    var changesDetected = this.updateObservers_();\n\n    // Continue running updates if changes have been detected as there might\n    // be future ones caused by CSS transitions.\n    if (changesDetected) {\n        this.refresh();\n    }\n};\n\n/**\r\n * Updates every observer from observers list and notifies them of queued\r\n * entries.\r\n *\r\n * @private\r\n * @returns {boolean} Returns \"true\" if any observer has detected changes in\r\n *  dimensions of it's elements.\r\n */\nResizeObserverController.prototype.updateObservers_ = function () {\n    // Collect observers that have active observations.\n    var activeObservers = this.observers_.filter(function (observer) {\n        return observer.gatherActive(), observer.hasActive();\n    });\n\n    // Deliver notifications in a separate cycle in order to avoid any\n    // collisions between observers, e.g. when multiple instances of\n    // ResizeObserver are tracking the same element and the callback of one\n    // of them changes content dimensions of the observed target. Sometimes\n    // this may result in notifications being blocked for the rest of observers.\n    activeObservers.forEach(function (observer) { return observer.broadcastActive(); });\n\n    return activeObservers.length > 0;\n};\n\n/**\r\n * Initializes DOM listeners.\r\n *\r\n * @private\r\n * @returns {void}\r\n */\nResizeObserverController.prototype.connect_ = function () {\n    // Do nothing if running in a non-browser environment or if listeners\n    // have been already added.\n    if (!isBrowser || this.connected_) {\n        return;\n    }\n\n    // Subscription to the \"Transitionend\" event is used as a workaround for\n    // delayed transitions. This way it's possible to capture at least the\n    // final state of an element.\n    document.addEventListener('transitionend', this.onTransitionEnd_);\n\n    window.addEventListener('resize', this.refresh);\n\n    if (mutationObserverSupported) {\n        this.mutationsObserver_ = new MutationObserver(this.refresh);\n\n        this.mutationsObserver_.observe(document, {\n            attributes: true,\n            childList: true,\n            characterData: true,\n            subtree: true\n        });\n    } else {\n        document.addEventListener('DOMSubtreeModified', this.refresh);\n\n        this.mutationEventsAdded_ = true;\n    }\n\n    this.connected_ = true;\n};\n\n/**\r\n * Removes DOM listeners.\r\n *\r\n * @private\r\n * @returns {void}\r\n */\nResizeObserverController.prototype.disconnect_ = function () {\n    // Do nothing if running in a non-browser environment or if listeners\n    // have been already removed.\n    if (!isBrowser || !this.connected_) {\n        return;\n    }\n\n    document.removeEventListener('transitionend', this.onTransitionEnd_);\n    window.removeEventListener('resize', this.refresh);\n\n    if (this.mutationsObserver_) {\n        this.mutationsObserver_.disconnect();\n    }\n\n    if (this.mutationEventsAdded_) {\n        document.removeEventListener('DOMSubtreeModified', this.refresh);\n    }\n\n    this.mutationsObserver_ = null;\n    this.mutationEventsAdded_ = false;\n    this.connected_ = false;\n};\n\n/**\r\n * \"Transitionend\" event handler.\r\n *\r\n * @private\r\n * @param {TransitionEvent} event\r\n * @returns {void}\r\n */\nResizeObserverController.prototype.onTransitionEnd_ = function (ref) {\n        var propertyName = ref.propertyName; if ( propertyName === void 0 ) propertyName = '';\n\n    // Detect whether transition may affect dimensions of an element.\n    var isReflowProperty = transitionKeys.some(function (key) {\n        return !!~propertyName.indexOf(key);\n    });\n\n    if (isReflowProperty) {\n        this.refresh();\n    }\n};\n\n/**\r\n * Returns instance of the ResizeObserverController.\r\n *\r\n * @returns {ResizeObserverController}\r\n */\nResizeObserverController.getInstance = function () {\n    if (!this.instance_) {\n        this.instance_ = new ResizeObserverController();\n    }\n\n    return this.instance_;\n};\n\nResizeObserverController.instance_ = null;\n\n/**\r\n * Defines non-writable/enumerable properties of the provided target object.\r\n *\r\n * @param {Object} target - Object for which to define properties.\r\n * @param {Object} props - Properties to be defined.\r\n * @returns {Object} Target object.\r\n */\nvar defineConfigurable = (function (target, props) {\n    for (var i = 0, list = Object.keys(props); i < list.length; i += 1) {\n        var key = list[i];\n\n        Object.defineProperty(target, key, {\n            value: props[key],\n            enumerable: false,\n            writable: false,\n            configurable: true\n        });\n    }\n\n    return target;\n});\n\n/**\r\n * Returns the global object associated with provided element.\r\n *\r\n * @param {Object} target\r\n * @returns {Object}\r\n */\nvar getWindowOf = (function (target) {\n    // Assume that the element is an instance of Node, which means that it\n    // has the \"ownerDocument\" property from which we can retrieve a\n    // corresponding global object.\n    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;\n\n    // Return the local global object if it's not possible extract one from\n    // provided element.\n    return ownerGlobal || global$1;\n});\n\n// Placeholder of an empty content rectangle.\nvar emptyRect = createRectInit(0, 0, 0, 0);\n\n/**\r\n * Converts provided string to a number.\r\n *\r\n * @param {number|string} value\r\n * @returns {number}\r\n */\nfunction toFloat(value) {\n    return parseFloat(value) || 0;\n}\n\n/**\r\n * Extracts borders size from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @param {...string} positions - Borders positions (top, right, ...)\r\n * @returns {number}\r\n */\nfunction getBordersSize(styles) {\n    var positions = [], len = arguments.length - 1;\n    while ( len-- > 0 ) positions[ len ] = arguments[ len + 1 ];\n\n    return positions.reduce(function (size, position) {\n        var value = styles['border-' + position + '-width'];\n\n        return size + toFloat(value);\n    }, 0);\n}\n\n/**\r\n * Extracts paddings sizes from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @returns {Object} Paddings box.\r\n */\nfunction getPaddings(styles) {\n    var positions = ['top', 'right', 'bottom', 'left'];\n    var paddings = {};\n\n    for (var i = 0, list = positions; i < list.length; i += 1) {\n        var position = list[i];\n\n        var value = styles['padding-' + position];\n\n        paddings[position] = toFloat(value);\n    }\n\n    return paddings;\n}\n\n/**\r\n * Calculates content rectangle of provided SVG element.\r\n *\r\n * @param {SVGGraphicsElement} target - Element content rectangle of which needs\r\n *      to be calculated.\r\n * @returns {DOMRectInit}\r\n */\nfunction getSVGContentRect(target) {\n    var bbox = target.getBBox();\n\n    return createRectInit(0, 0, bbox.width, bbox.height);\n}\n\n/**\r\n * Calculates content rectangle of provided HTMLElement.\r\n *\r\n * @param {HTMLElement} target - Element for which to calculate the content rectangle.\r\n * @returns {DOMRectInit}\r\n */\nfunction getHTMLElementContentRect(target) {\n    // Client width & height properties can't be\n    // used exclusively as they provide rounded values.\n    var clientWidth = target.clientWidth;\n    var clientHeight = target.clientHeight;\n\n    // By this condition we can catch all non-replaced inline, hidden and\n    // detached elements. Though elements with width & height properties less\n    // than 0.5 will be discarded as well.\n    //\n    // Without it we would need to implement separate methods for each of\n    // those cases and it's not possible to perform a precise and performance\n    // effective test for hidden elements. E.g. even jQuery's ':visible' filter\n    // gives wrong results for elements with width & height less than 0.5.\n    if (!clientWidth && !clientHeight) {\n        return emptyRect;\n    }\n\n    var styles = getWindowOf(target).getComputedStyle(target);\n    var paddings = getPaddings(styles);\n    var horizPad = paddings.left + paddings.right;\n    var vertPad = paddings.top + paddings.bottom;\n\n    // Computed styles of width & height are being used because they are the\n    // only dimensions available to JS that contain non-rounded values. It could\n    // be possible to utilize the getBoundingClientRect if only it's data wasn't\n    // affected by CSS transformations let alone paddings, borders and scroll bars.\n    var width = toFloat(styles.width),\n        height = toFloat(styles.height);\n\n    // Width & height include paddings and borders when the 'border-box' box\n    // model is applied (except for IE).\n    if (styles.boxSizing === 'border-box') {\n        // Following conditions are required to handle Internet Explorer which\n        // doesn't include paddings and borders to computed CSS dimensions.\n        //\n        // We can say that if CSS dimensions + paddings are equal to the \"client\"\n        // properties then it's either IE, and thus we don't need to subtract\n        // anything, or an element merely doesn't have paddings/borders styles.\n        if (Math.round(width + horizPad) !== clientWidth) {\n            width -= getBordersSize(styles, 'left', 'right') + horizPad;\n        }\n\n        if (Math.round(height + vertPad) !== clientHeight) {\n            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;\n        }\n    }\n\n    // Following steps can't be applied to the document's root element as its\n    // client[Width/Height] properties represent viewport area of the window.\n    // Besides, it's as well not necessary as the <html> itself neither has\n    // rendered scroll bars nor it can be clipped.\n    if (!isDocumentElement(target)) {\n        // In some browsers (only in Firefox, actually) CSS width & height\n        // include scroll bars size which can be removed at this step as scroll\n        // bars are the only difference between rounded dimensions + paddings\n        // and \"client\" properties, though that is not always true in Chrome.\n        var vertScrollbar = Math.round(width + horizPad) - clientWidth;\n        var horizScrollbar = Math.round(height + vertPad) - clientHeight;\n\n        // Chrome has a rather weird rounding of \"client\" properties.\n        // E.g. for an element with content width of 314.2px it sometimes gives\n        // the client width of 315px and for the width of 314.7px it may give\n        // 314px. And it doesn't happen all the time. So just ignore this delta\n        // as a non-relevant.\n        if (Math.abs(vertScrollbar) !== 1) {\n            width -= vertScrollbar;\n        }\n\n        if (Math.abs(horizScrollbar) !== 1) {\n            height -= horizScrollbar;\n        }\n    }\n\n    return createRectInit(paddings.left, paddings.top, width, height);\n}\n\n/**\r\n * Checks whether provided element is an instance of the SVGGraphicsElement.\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\nvar isSVGGraphicsElement = (function () {\n    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement\n    // interface.\n    if (typeof SVGGraphicsElement !== 'undefined') {\n        return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };\n    }\n\n    // If it's so, then check that element is at least an instance of the\n    // SVGElement and that it has the \"getBBox\" method.\n    // eslint-disable-next-line no-extra-parens\n    return function (target) { return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === 'function'; };\n})();\n\n/**\r\n * Checks whether provided element is a document element (<html>).\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\nfunction isDocumentElement(target) {\n    return target === getWindowOf(target).document.documentElement;\n}\n\n/**\r\n * Calculates an appropriate content rectangle for provided html or svg element.\r\n *\r\n * @param {Element} target - Element content rectangle of which needs to be calculated.\r\n * @returns {DOMRectInit}\r\n */\nfunction getContentRect(target) {\n    if (!isBrowser) {\n        return emptyRect;\n    }\n\n    if (isSVGGraphicsElement(target)) {\n        return getSVGContentRect(target);\n    }\n\n    return getHTMLElementContentRect(target);\n}\n\n/**\r\n * Creates rectangle with an interface of the DOMRectReadOnly.\r\n * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly\r\n *\r\n * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.\r\n * @returns {DOMRectReadOnly}\r\n */\nfunction createReadOnlyRect(ref) {\n    var x = ref.x;\n    var y = ref.y;\n    var width = ref.width;\n    var height = ref.height;\n\n    // If DOMRectReadOnly is available use it as a prototype for the rectangle.\n    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;\n    var rect = Object.create(Constr.prototype);\n\n    // Rectangle's properties are not writable and non-enumerable.\n    defineConfigurable(rect, {\n        x: x, y: y, width: width, height: height,\n        top: y,\n        right: x + width,\n        bottom: height + y,\n        left: x\n    });\n\n    return rect;\n}\n\n/**\r\n * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.\r\n * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit\r\n *\r\n * @param {number} x - X coordinate.\r\n * @param {number} y - Y coordinate.\r\n * @param {number} width - Rectangle's width.\r\n * @param {number} height - Rectangle's height.\r\n * @returns {DOMRectInit}\r\n */\nfunction createRectInit(x, y, width, height) {\n    return { x: x, y: y, width: width, height: height };\n}\n\n/**\r\n * Class that is responsible for computations of the content rectangle of\r\n * provided DOM element and for keeping track of it's changes.\r\n */\nvar ResizeObservation = function(target) {\n    this.broadcastWidth = 0;\n    this.broadcastHeight = 0;\n    this.contentRect_ = createRectInit(0, 0, 0, 0);\n\n    this.target = target;\n};\n\n/**\r\n * Updates content rectangle and tells whether it's width or height properties\r\n * have changed since the last broadcast.\r\n *\r\n * @returns {boolean}\r\n */\n\n\n/**\r\n * Reference to the last observed content rectangle.\r\n *\r\n * @private {DOMRectInit}\r\n */\n\n\n/**\r\n * Broadcasted width of content rectangle.\r\n *\r\n * @type {number}\r\n */\nResizeObservation.prototype.isActive = function () {\n    var rect = getContentRect(this.target);\n\n    this.contentRect_ = rect;\n\n    return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;\n};\n\n/**\r\n * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data\r\n * from the corresponding properties of the last observed content rectangle.\r\n *\r\n * @returns {DOMRectInit} Last observed content rectangle.\r\n */\nResizeObservation.prototype.broadcastRect = function () {\n    var rect = this.contentRect_;\n\n    this.broadcastWidth = rect.width;\n    this.broadcastHeight = rect.height;\n\n    return rect;\n};\n\nvar ResizeObserverEntry = function(target, rectInit) {\n    var contentRect = createReadOnlyRect(rectInit);\n\n    // According to the specification following properties are not writable\n    // and are also not enumerable in the native implementation.\n    //\n    // Property accessors are not being used as they'd require to define a\n    // private WeakMap storage which may cause memory leaks in browsers that\n    // don't support this type of collections.\n    defineConfigurable(this, { target: target, contentRect: contentRect });\n};\n\nvar ResizeObserverSPI = function(callback, controller, callbackCtx) {\n    this.activeObservations_ = [];\n    this.observations_ = new MapShim();\n\n    if (typeof callback !== 'function') {\n        throw new TypeError('The callback provided as parameter 1 is not a function.');\n    }\n\n    this.callback_ = callback;\n    this.controller_ = controller;\n    this.callbackCtx_ = callbackCtx;\n};\n\n/**\r\n * Starts observing provided element.\r\n *\r\n * @param {Element} target - Element to be observed.\r\n * @returns {void}\r\n */\n\n\n/**\r\n * Registry of the ResizeObservation instances.\r\n *\r\n * @private {Map<Element, ResizeObservation>}\r\n */\n\n\n/**\r\n * Public ResizeObserver instance which will be passed to the callback\r\n * function and used as a value of it's \"this\" binding.\r\n *\r\n * @private {ResizeObserver}\r\n */\n\n/**\r\n * Collection of resize observations that have detected changes in dimensions\r\n * of elements.\r\n *\r\n * @private {Array<ResizeObservation>}\r\n */\nResizeObserverSPI.prototype.observe = function (target) {\n    if (!arguments.length) {\n        throw new TypeError('1 argument required, but only 0 present.');\n    }\n\n    // Do nothing if current environment doesn't have the Element interface.\n    if (typeof Element === 'undefined' || !(Element instanceof Object)) {\n        return;\n    }\n\n    if (!(target instanceof getWindowOf(target).Element)) {\n        throw new TypeError('parameter 1 is not of type \"Element\".');\n    }\n\n    var observations = this.observations_;\n\n    // Do nothing if element is already being observed.\n    if (observations.has(target)) {\n        return;\n    }\n\n    observations.set(target, new ResizeObservation(target));\n\n    this.controller_.addObserver(this);\n\n    // Force the update of observations.\n    this.controller_.refresh();\n};\n\n/**\r\n * Stops observing provided element.\r\n *\r\n * @param {Element} target - Element to stop observing.\r\n * @returns {void}\r\n */\nResizeObserverSPI.prototype.unobserve = function (target) {\n    if (!arguments.length) {\n        throw new TypeError('1 argument required, but only 0 present.');\n    }\n\n    // Do nothing if current environment doesn't have the Element interface.\n    if (typeof Element === 'undefined' || !(Element instanceof Object)) {\n        return;\n    }\n\n    if (!(target instanceof getWindowOf(target).Element)) {\n        throw new TypeError('parameter 1 is not of type \"Element\".');\n    }\n\n    var observations = this.observations_;\n\n    // Do nothing if element is not being observed.\n    if (!observations.has(target)) {\n        return;\n    }\n\n    observations.delete(target);\n\n    if (!observations.size) {\n        this.controller_.removeObserver(this);\n    }\n};\n\n/**\r\n * Stops observing all elements.\r\n *\r\n * @returns {void}\r\n */\nResizeObserverSPI.prototype.disconnect = function () {\n    this.clearActive();\n    this.observations_.clear();\n    this.controller_.removeObserver(this);\n};\n\n/**\r\n * Collects observation instances the associated element of which has changed\r\n * it's content rectangle.\r\n *\r\n * @returns {void}\r\n */\nResizeObserverSPI.prototype.gatherActive = function () {\n        var this$1 = this;\n\n    this.clearActive();\n\n    this.observations_.forEach(function (observation) {\n        if (observation.isActive()) {\n            this$1.activeObservations_.push(observation);\n        }\n    });\n};\n\n/**\r\n * Invokes initial callback function with a list of ResizeObserverEntry\r\n * instances collected from active resize observations.\r\n *\r\n * @returns {void}\r\n */\nResizeObserverSPI.prototype.broadcastActive = function () {\n    // Do nothing if observer doesn't have active observations.\n    if (!this.hasActive()) {\n        return;\n    }\n\n    var ctx = this.callbackCtx_;\n\n    // Create ResizeObserverEntry instance for every active observation.\n    var entries = this.activeObservations_.map(function (observation) {\n        return new ResizeObserverEntry(observation.target, observation.broadcastRect());\n    });\n\n    this.callback_.call(ctx, entries, ctx);\n    this.clearActive();\n};\n\n/**\r\n * Clears the collection of active observations.\r\n *\r\n * @returns {void}\r\n */\nResizeObserverSPI.prototype.clearActive = function () {\n    this.activeObservations_.splice(0);\n};\n\n/**\r\n * Tells whether observer has active observations.\r\n *\r\n * @returns {boolean}\r\n */\nResizeObserverSPI.prototype.hasActive = function () {\n    return this.activeObservations_.length > 0;\n};\n\n// Registry of internal observers. If WeakMap is not available use current shim\n// for the Map collection as it has all required methods and because WeakMap\n// can't be fully polyfilled anyway.\nvar observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();\n\n/**\r\n * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation\r\n * exposing only those methods and properties that are defined in the spec.\r\n */\nvar ResizeObserver = function(callback) {\n    if (!(this instanceof ResizeObserver)) {\n        throw new TypeError('Cannot call a class as a function.');\n    }\n    if (!arguments.length) {\n        throw new TypeError('1 argument required, but only 0 present.');\n    }\n\n    var controller = ResizeObserverController.getInstance();\n    var observer = new ResizeObserverSPI(callback, controller, this);\n\n    observers.set(this, observer);\n};\n\n// Expose public methods of ResizeObserver.\n['observe', 'unobserve', 'disconnect'].forEach(function (method) {\n    ResizeObserver.prototype[method] = function () {\n        return (ref = observers.get(this))[method].apply(ref, arguments);\n        var ref;\n    };\n});\n\nvar index = (function () {\n    // Export existing implementation if available.\n    if (typeof global$1.ResizeObserver !== 'undefined') {\n        return global$1.ResizeObserver;\n    }\n\n    return ResizeObserver;\n})();\n\nexport default index;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js\n// module id = 5\n// module chunks = 0","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 6\n// module chunks = 0","const TOKENIZE_POLICY = {\n  characters: {\n    tokenizeString: null,\n    isAtomic: str => str.length <= 1,\n  },\n  words: {\n    tokenizeString: str => str.match(/(\\s*\\S[\\S\\xA0]*)/g),\n    isAtomic: str => /^\\s*[\\S\\xA0]*\\s*$/.test(str),\n  },\n};\n\nexport default TOKENIZE_POLICY;\n\n\n\n// WEBPACK FOOTER //\n// ./src/tokenize-rules.js"],"sourceRoot":""}